<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Festival Bingo</title>
  <link rel="manifest" href="manifest.webmanifest">
  <style>
  :root {
  --gap: 10px;
  --radius: 14px;
  --shadow: 0 6px 18px rgba(0,0,0,.10);
}

* { box-sizing: border-box; }
body {
  margin: 0;
  font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
  background: #fafafa;
  color: #111;
}

.daypick { display:flex; gap:10px; margin-bottom:10px; }
.daypick button.active { background:#111; color:#fff; border-color:#111; }

.topbar {
  position: sticky;
  top: 0;
  background: white;
  padding: 14px 14px 10px;
  border-bottom: 1px solid #eee;
  z-index: 10;
}

h1 {
  font-size: 18px;
  margin: 0 0 10px;
}

.actions {
  display: flex;
  gap: 10px;
  margin-bottom: 8px;
}

button {
  padding: 10px 12px;
  border: 1px solid #ddd;
  background: #fff;
  border-radius: 12px;
  box-shadow: var(--shadow);
  font-weight: 600;
}

button:active { transform: translateY(1px); }

.status {
  margin: 0;
  font-size: 13px;
  color: #444;
}

main {
  padding: 14px;
  max-width: 820px;
  margin: 0 auto;
}

.grid {
  display: grid;
  grid-template-columns: repeat(5, minmax(0, 1fr));
  gap: var(--gap);
}

.square {
  user-select: none;
  min-height: 90px;
  padding: 10px;
  border-radius: var(--radius);
  border: 1px solid #e7e7e7;
  background: white;
  box-shadow: var(--shadow);
  display: flex;
  align-items: center;
  justify-content: center;
  text-align: center;
  line-height: 1.2;
  font-weight: 650;
  font-size: 14px;
}

.square.checked {
  border-color: #111;
  background: #111;
  color: #fff;
}

.footer {
  padding: 14px;
  text-align: center;
  color: #666;
}
</style>
</head>
<body>
  <header class="topbar">
    <h1>Festival Bingo</h1>
    <div class="daypick">
  <button id="day1Btn" type="button">Day 1</button>
  <button id="day2Btn" type="button">Day 2</button>
</div>
    <div class="actions">
      <button id="newBoardBtn" type="button">New board</button>
      <button id="resetTicksBtn" type="button">Reset ticks</button>
    </div>
    <p class="status" id="status"></p>
  </header>

  <main>
    <section class="grid" id="grid" aria-label="Bingo grid"></section>
  </main>

  <footer class="footer">
    <small>
      Tip: open once before you leave to cache it for offline.
    </small>
  </footer>

  <script>// -------------- CONFIG --------------
/* =========================
   Festival Bingo (Day 1 + Day 2)
   - Fetches one published Google Sheet CSV (Col A = Day 1, Col B = Day 2)
   - Generates a shuffled 5x5 board per day, per device
   - Saves board + ticks in localStorage (survives refresh)
   - Works offline if you use sw.js to cache index.html + the CSV
   ========================= */

/* -------- CONFIG -------- */
const SHEET_CSV_URL = "https://docs.google.com/spreadsheets/d/e/2PACX-1vQ2Yj9ONo5kfoZo1aRy8W4JniBbm36PqEy_Q93wYempTgNjeYxXt_U3V5vGoyUG9cgTTT2NcThJHpEz/pub?output=csv";
const GRID_SIZE = 25; // 5x5
const STORE_KEY_PREFIX = "festival-bingo-v1-day-"; // + "1" or "2"
const OPTIONS_CACHE_KEY = "festival-bingo-v1-options-cache"; // stores last good options (for offline fallback)

/* -------- DOM HELPERS -------- */
function $(id) {
  return document.getElementById(id);
}

function setStatus(msg) {
  const el = $("status");
  if (el) el.textContent = msg;
}

/* -------- LOCAL STORAGE -------- */
function storeKeyForDay(day) {
  return `${STORE_KEY_PREFIX}${day}`;
}

function loadStateForDay(day) {
  try {
    const raw = localStorage.getItem(storeKeyForDay(day));
    return raw ? JSON.parse(raw) : null;
  } catch {
    return null;
  }
}

function saveStateForDay(day, state) {
  localStorage.setItem(storeKeyForDay(day), JSON.stringify(state));
}

function loadCachedOptions() {
  try {
    const raw = localStorage.getItem(OPTIONS_CACHE_KEY);
    return raw ? JSON.parse(raw) : null;
  } catch {
    return null;
  }
}

function saveCachedOptions(optionsByDay) {
  localStorage.setItem(OPTIONS_CACHE_KEY, JSON.stringify({
    savedAt: new Date().toISOString(),
    ...optionsByDay
  }));
}

/* -------- RANDOM / SHUFFLE -------- */
function randomInt(min, maxExclusive) {
  const range = maxExclusive - min;
  if (range <= 0) return min;

  if (crypto?.getRandomValues) {
    const maxUint = 0xFFFFFFFF;
    const limit = maxUint - (maxUint % range);
    const buf = new Uint32Array(1);
    while (true) {
      crypto.getRandomValues(buf);
      const x = buf[0];
      if (x < limit) return min + (x % range);
    }
  }
  return min + Math.floor(Math.random() * range);
}

function shuffleInPlace(arr) {
  for (let i = arr.length - 1; i > 0; i--) {
    const j = randomInt(0, i + 1);
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
  return arr;
}

/* -------- CSV PARSING (ROBUST) -------- */
function parseCSVToRows(text) {
  const rows = [];
  let row = [];
  let field = "";
  let inQuotes = false;

  for (let i = 0; i < text.length; i++) {
    const c = text[i];
    const next = text[i + 1];

    if (inQuotes) {
      if (c === '"' && next === '"') {
        field += '"';
        i++;
      } else if (c === '"') {
        inQuotes = false;
      } else {
        field += c;
      }
    } else {
      if (c === '"') {
        inQuotes = true;
      } else if (c === ",") {
        row.push(field);
        field = "";
      } else if (c === "\n") {
        row.push(field);
        rows.push(row);
        row = [];
        field = "";
      } else if (c === "\r") {
        // ignore CR
      } else {
        field += c;
      }
    }
  }

  // Add last field/row
  row.push(field);
  rows.push(row);

  return rows;
}

// Your sheet: Col A = Day 1, Col B = Day 2, headers in row 1
function extractDayListsFromCSV(text) {
  const rows = parseCSVToRows(text);

  const day1 = [];
  const day2 = [];

  for (let r = 1; r < rows.length; r++) { // skip header row
    const a = (rows[r][0] ?? "").trim();
    const b = (rows[r][1] ?? "").trim();
    if (a) day1.push(a);
    if (b) day2.push(b);
  }

  return { day1, day2 };
}

/* -------- OPTIONS HASH (CHANGE DETECTION) -------- */
function hashList(list) {
  // Simple non-crypto hash
  let h = 2166136261;
  for (const s of list) {
    for (let i = 0; i < s.length; i++) {
      h ^= s.charCodeAt(i);
      h = Math.imul(h, 16777619);
    }
  }
  return String(h >>> 0);
}

function hashOptionsByDay(optionsByDay) {
  return `${hashList(optionsByDay.day1)}-${hashList(optionsByDay.day2)}`;
}

/* -------- BOARD GENERATION -------- */
function makeNewBoardFromOptions(items) {
  const pool = [...items];
  shuffleInPlace(pool);
  const board = pool.slice(0, GRID_SIZE);

  return {
    createdAt: new Date().toISOString(),
    board,
    checked: Array(GRID_SIZE).fill(false)
  };
}

/* -------- RENDERING -------- */
function renderBoard(state) {
  const grid = $("grid");
  if (!grid) return;

  grid.innerHTML = "";

  state.board.forEach((text, idx) => {
    const btn = document.createElement("button");
    btn.type = "button";
    btn.className = "square" + (state.checked[idx] ? " checked" : "");
    btn.textContent = text;

    btn.addEventListener("click", () => {
      state.checked[idx] = !state.checked[idx];
      saveStateForDay(app.currentDay, state);
      btn.classList.toggle("checked", state.checked[idx]);
    });

    grid.appendChild(btn);
  });
}

/* -------- APP STATE -------- */
const app = {
  currentDay: 1,
  optionsByDay: { day1: [], day2: [] },
  optionsHash: null,
  state: null
};

/* -------- FETCH + LOAD -------- */
async function fetchAllOptions() {
  const res = await fetch(SHEET_CSV_URL, { cache: "no-store" });
  if (!res.ok) throw new Error(`Fetch failed: ${res.status}`);
  const text = await res.text();
  const optionsByDay = extractDayListsFromCSV(text);

  if (optionsByDay.day1.length < GRID_SIZE) {
    throw new Error(`Day 1 needs at least ${GRID_SIZE} ideas (found ${optionsByDay.day1.length}).`);
  }
  if (optionsByDay.day2.length < GRID_SIZE) {
    throw new Error(`Day 2 needs at least ${GRID_SIZE} ideas (found ${optionsByDay.day2.length}).`);
  }

  return optionsByDay;
}

function getListForDay(day) {
  return day === 1 ? app.optionsByDay.day1 : app.optionsByDay.day2;
}

function setActiveDayButtons(day) {
  const d1 = $("day1Btn");
  const d2 = $("day2Btn");
  if (d1) d1.classList.toggle("active", day === 1);
  if (d2) d2.classList.toggle("active", day === 2);
}

async function loadDay(day) {
  app.currentDay = day;
  setActiveDayButtons(day);

  // Load saved board state for this day
  app.state = loadStateForDay(day);

  // Try to ensure we have options lists
  // 1) network (or SW cached fetch)
  // 2) fallback to local cached options
  try {
    setStatus(`Loading squares (Day ${day})…`);
    app.optionsByDay = await fetchAllOptions();
    app.optionsHash = hashOptionsByDay(app.optionsByDay);
    saveCachedOptions({ day1: app.optionsByDay.day1, day2: app.optionsByDay.day2, optionsHash: app.optionsHash });

    // If no state yet for this day, create one
    if (!app.state) {
      const list = getListForDay(day);
      app.state = makeNewBoardFromOptions(list);
      // store hash so we can warn if ideas changed later
      app.state.optionsHash = app.optionsHash;
      saveStateForDay(day, app.state);
      setStatus(`Day ${day} ready. New board created.`);
    } else {
      // If ideas changed since this board was made, keep board but update stored hash
      if (app.state.optionsHash && app.state.optionsHash !== app.optionsHash) {
        setStatus(`Squares updated since last time. Your Day ${day} board is kept — tap “New board” to reshuffle.`);
        app.state.optionsHash = app.optionsHash;
        saveStateForDay(day, app.state);
      } else {
        setStatus(navigator.onLine ? `Day ${day} ready (online).` : `Day ${day} ready (offline).`);
      }
    }
  } catch (e) {
    // fallback to cached options (localStorage)
    const cached = loadCachedOptions();
    if (cached?.day1?.length >= GRID_SIZE && cached?.day2?.length >= GRID_SIZE) {
      app.optionsByDay = { day1: cached.day1, day2: cached.day2 };
      app.optionsHash = cached.optionsHash || hashOptionsByDay(app.optionsByDay);

      if (!app.state) {
        // We can still create a new board from cached options even offline
        const list = getListForDay(day);
        app.state = makeNewBoardFromOptions(list);
        app.state.optionsHash = app.optionsHash;
        saveStateForDay(day, app.state);
        setStatus(`Offline: created a new Day ${day} board from cached squares.`);
      } else {
        setStatus(`Offline: using saved Day ${day} board.`);
      }
    } else if (app.state?.board?.length === GRID_SIZE) {
      // We have a saved board but not the options lists; still playable
      setStatus(`Offline: using saved Day ${day} board.`);
    } else {
      setStatus(`Couldn’t load squares. Go online once before leaving to set up Day ${day}.`);
      console.error(e);
      return;
    }
  }

  renderBoard(app.state);
}

/* -------- BUTTON WIRES -------- */
function wireUI() {
  $("day1Btn")?.addEventListener("click", () => loadDay(1));
  $("day2Btn")?.addEventListener("click", () => loadDay(2));

  $("newBoardBtn")?.addEventListener("click", () => {
    const list = getListForDay(app.currentDay);
    if (!list?.length) {
      setStatus("Squares list not loaded yet — go online once.");
      return;
    }
    app.state = makeNewBoardFromOptions(list);
    app.state.optionsHash = app.optionsHash || hashOptionsByDay(app.optionsByDay);
    saveStateForDay(app.currentDay, app.state);
    renderBoard(app.state);
    setStatus(`Day ${app.currentDay}: new board created.`);
  });

  $("resetTicksBtn")?.addEventListener("click", () => {
    if (!app.state) return;
    app.state.checked = Array(GRID_SIZE).fill(false);
    saveStateForDay(app.currentDay, app.state);
    renderBoard(app.state);
    setStatus(`Day ${app.currentDay}: ticks reset.`);
  });
}

/* -------- SERVICE WORKER (optional but recommended) -------- */
async function registerServiceWorker() {
  if (!("serviceWorker" in navigator)) return;
  try {
    await navigator.serviceWorker.register("./sw.js");
  } catch (e) {
    console.warn("Service worker registration failed:", e);
  }
}

/* -------- INIT -------- */
(async function init() {
  await registerServiceWorker();
  wireUI();

  // Default to Day 1
  await loadDay(1);

  // Optional: if you're online, lightly “warm” the cache by fetching once more in background
  // (this helps some browsers cache the CSV early)
  if (navigator.onLine) {
    fetchAllOptions()
      .then(opts => saveCachedOptions({ day1: opts.day1, day2: opts.day2, optionsHash: hashOptionsByDay(opts) }))
      .catch(() => {});
  }
})();
</script>
</body>
</html>
